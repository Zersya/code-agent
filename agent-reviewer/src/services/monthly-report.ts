import { dbService } from './database.js';
import {
  MonthlyReportData,
  ActionPoint,
  TopContributor,
  QualityMetric,
  AutoGeneratedData,
  Highlight,
  Lowlight
} from '../models/monthly-report.js';
import { startOfMonth, endOfMonth, subMonths, format, differenceInHours } from 'date-fns';
import axios from 'axios';
import dotenv from 'dotenv';

dotenv.config();

const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY;
const OPENROUTER_API_URL = process.env.OPENROUTER_API_URL || 'https://openrouter.ai/api/v1';

export class MonthlyReportService {
  /**
   * Auto-generate monthly report data from existing database records
   */
  async generateMonthlyReportData(month: number, year: number): Promise<MonthlyReportData> {
    const startDate = startOfMonth(new Date(year, month - 1));
    const endDate = endOfMonth(new Date(year, month - 1));
    const previousMonthStart = startOfMonth(subMonths(startDate, 1));
    const previousMonthEnd = endOfMonth(subMonths(startDate, 1));

    // Generate each section
    const actionPoints = await this.generateActionPoints(startDate, endDate);
    const mrDashboard = await this.generateMRDashboard(startDate, endDate);
    const qualityMetrics = await this.generateQualityMetrics(startDate, endDate, previousMonthStart, previousMonthEnd);

    // Generate highlights and lowlights
    const highlights = await this.generateHighlights(startDate, endDate);
    const lowlights = await this.generateLowlights(startDate, endDate);

    const reportData: MonthlyReportData = {
      month,
      year,
      actionPoints,
      highlights,
      lowlights,
      techUpdate: {
        mergeRequestDashboard: mrDashboard,
        toolingChanges: [
          { description: 'Add tooling/infrastructure changes here' }
        ]
      },
      lessonsLearned: [
        {
          whatHappened: 'Describe what happened',
          whyItMatters: 'Explain why it matters',
          nextAction: 'Define preventive action'
        }
      ],
      productStrategy: {
        feedbackSummary: 'Add feedback summary here',
        feedbackLink: '',
        qualityMetrics
      },
      budgeting: {
        items: []
      },
      thankYouNote: 'Thank you to the team for your hard work this month! üëè'
    };

    return reportData;
  }

  /**
   * Generate action points from closed merge requests
   */
  private async generateActionPoints(startDate: Date, endDate: Date): Promise<ActionPoint[]> {
    const query = `
      SELECT
        mrt.title,
        mrt.author_username,
        mrt.merged_at,
        mrt.closed_at,
        mrt.status,
        p.name as project_name
      FROM merge_request_tracking mrt
      LEFT JOIN projects p ON mrt.project_id = p.project_id
      WHERE mrt.merged_at BETWEEN $1 AND $2
        OR mrt.closed_at BETWEEN $1 AND $2
      ORDER BY COALESCE(mrt.merged_at, mrt.closed_at) DESC
      LIMIT 50
    `;

    const result = await dbService.query(query, [startDate, endDate]);

    return result.rows.map(row => {
      // Minify action text - truncate if too long
      const action = row.title.length > 60
        ? row.title.substring(0, 57) + '...'
        : row.title;

      return {
        date: format(new Date(row.merged_at || row.closed_at), 'yyyy-MM-dd'),
        action,
        pic: row.author_username,
        status: row.status === 'merged' ? 'finish' as const : 'drop' as const,
        project_name: row.project_name || 'Unknown'
      };
    });
  }

  /**
   * Generate MR dashboard metrics
   */
  private async generateMRDashboard(startDate: Date, endDate: Date) {
    // Get total MRs created and merged
    const mrStatsQuery = `
      SELECT
        COUNT(*) as total_created,
        COUNT(CASE WHEN status = 'merged' THEN 1 END) as total_merged
      FROM merge_request_tracking
      WHERE created_at BETWEEN $1 AND $2
    `;
    const mrStatsResult = await dbService.query(mrStatsQuery, [startDate, endDate]);
    const mrStats = mrStatsResult.rows[0];

    const totalCreated = parseInt(mrStats.total_created) || 0;
    const totalMerged = parseInt(mrStats.total_merged) || 0;
    const mergeRate = totalCreated > 0 ? (totalMerged / totalCreated) * 100 : 0;

    // Get top contributors
    const topContributorsQuery = `
      SELECT
        author_username,
        COUNT(*) as mr_count
      FROM merge_request_tracking
      WHERE created_at BETWEEN $1 AND $2
      GROUP BY author_username
      ORDER BY mr_count DESC
      LIMIT 3
    `;
    const topContributorsResult = await dbService.query(topContributorsQuery, [startDate, endDate]);

    const topContributors: TopContributor[] = topContributorsResult.rows.map(row => ({
      username: row.author_username,
      mrCount: parseInt(row.mr_count)
    }));

    return {
      totalMRCreated: totalCreated,
      totalMRMerged: totalMerged,
      mergeRate: Math.round(mergeRate * 100) / 100,
      topContributors
    };
  }

  /**
   * Generate highlights from highest-point Notion tasks (from different projects)
   */
  private async generateHighlights(startDate: Date, endDate: Date): Promise<Highlight[]> {
    // Query to get tasks with highest points that have merged MRs
    const query = `
      WITH task_mrs AS (
        SELECT
          nt.id as task_id,
          nt.title as task_title,
          nt.points,
          p.name as project_name,
          mrt.title as mr_title,
          mrt.description as mr_description,
          mrt.author_username,
          mrt.web_url as mr_url
        FROM notion_tasks nt
        INNER JOIN task_mr_mappings tmm ON nt.id = tmm.notion_task_id
        INNER JOIN merge_request_tracking mrt ON tmm.project_id = mrt.project_id
          AND tmm.merge_request_iid = mrt.merge_request_iid
        LEFT JOIN projects p ON mrt.project_id = p.project_id
        WHERE mrt.merged_at BETWEEN $1 AND $2
          AND mrt.status = 'merged'
          AND nt.points IS NOT NULL
          AND nt.points > 0
      ),
      grouped_by_points AS (
        SELECT
          points,
          json_agg(json_build_object(
            'task_title', task_title,
            'project_name', project_name,
            'mr_title', mr_title,
            'mr_description', mr_description,
            'author_username', author_username,
            'mr_url', mr_url
          )) as mrs
        FROM task_mrs
        GROUP BY points
        ORDER BY points DESC
        LIMIT 5
      )
      SELECT * FROM grouped_by_points
    `;

    const result = await dbService.query(query, [startDate, endDate]);

    if (result.rows.length === 0) {
      return [{ description: 'Add your highlights here', completed: false }];
    }

    // Process each point group with LLM
    const highlights: Highlight[] = [];
    for (const row of result.rows) {
      const points = row.points;
      const mrs = row.mrs;

      const llmDescription = await this.generateHighlightDescriptionFromMultipleMRs(
        points,
        mrs
      );

      highlights.push({
        description: llmDescription,
        completed: true
      });
    }

    return highlights;
  }

  /**
   * Generate lowlights from lowest-point Notion tasks (from different projects)
   */
  private async generateLowlights(startDate: Date, endDate: Date): Promise<Lowlight[]> {
    // Query to get tasks with lowest points that have merged MRs with issues
    const query = `
      WITH task_mrs AS (
        SELECT
          nt.id as task_id,
          nt.title as task_title,
          nt.points,
          p.name as project_name,
          mrt.title as mr_title,
          mrt.description as mr_description,
          mrt.author_username,
          mrt.web_url as mr_url,
          mrr.critical_issues_count
        FROM notion_tasks nt
        INNER JOIN task_mr_mappings tmm ON nt.id = tmm.notion_task_id
        INNER JOIN merge_request_tracking mrt ON tmm.project_id = mrt.project_id
          AND tmm.merge_request_iid = mrt.merge_request_iid
        LEFT JOIN projects p ON mrt.project_id = p.project_id
        LEFT JOIN merge_request_reviews mrr ON mrt.project_id = mrr.project_id
          AND mrt.merge_request_iid = mrr.merge_request_iid
        WHERE mrt.merged_at BETWEEN $1 AND $2
          AND mrt.status = 'merged'
          AND nt.points IS NOT NULL
          AND nt.points > 0
          AND (mrr.critical_issues_count > 0 OR mrr.critical_issues_count IS NULL)
      ),
      grouped_by_points AS (
        SELECT
          points,
          json_agg(json_build_object(
            'task_title', task_title,
            'project_name', project_name,
            'mr_title', mr_title,
            'mr_description', mr_description,
            'author_username', author_username,
            'mr_url', mr_url,
            'critical_issues_count', critical_issues_count
          )) as mrs
        FROM task_mrs
        GROUP BY points
        ORDER BY points ASC
        LIMIT 5
      )
      SELECT * FROM grouped_by_points
    `;

    const result = await dbService.query(query, [startDate, endDate]);

    if (result.rows.length === 0) {
      return [];
    }

    // Process each point group with LLM
    const lowlights: Lowlight[] = [];
    for (const row of result.rows) {
      const points = row.points;
      const mrs = row.mrs;

      const llmDescription = await this.generateLowlightDescriptionFromMultipleMRs(
        points,
        mrs
      );

      lowlights.push({
        description: llmDescription,
        completed: false
      });
    }

    return lowlights;
  }

  /**
   * Generate quality metrics comparing current month to previous month
   */
  private async generateQualityMetrics(
    currentStart: Date,
    currentEnd: Date,
    previousStart: Date,
    previousEnd: Date
  ): Promise<QualityMetric[]> {
    const metrics: QualityMetric[] = [];

    // Average PR review time
    const reviewTimeQuery = `
      SELECT
        AVG(EXTRACT(EPOCH FROM (reviewed_at - created_at)) / 3600) as avg_hours
      FROM merge_request_reviews
      WHERE reviewed_at BETWEEN $1 AND $2
    `;

    const currentReviewTime = await dbService.query(reviewTimeQuery, [currentStart, currentEnd]);
    const previousReviewTime = await dbService.query(reviewTimeQuery, [previousStart, previousEnd]);

    const currentAvg = parseFloat(currentReviewTime.rows[0]?.avg_hours) || 0;
    const previousAvg = parseFloat(previousReviewTime.rows[0]?.avg_hours) || 0;

    metrics.push({
      metric: 'Average PR review time',
      previousValue: Math.round(previousAvg * 10) / 10,
      currentValue: Math.round(currentAvg * 10) / 10,
      trend: currentAvg < previousAvg ? 'down' : currentAvg > previousAvg ? 'up' : 'stable',
      unit: 'hours'
    });

    // Unit test coverage (if available - placeholder for now)
    // This would need to be tracked separately in your system
    metrics.push({
      metric: 'Unit-test coverage',
      previousValue: 0,
      currentValue: 0,
      trend: 'stable',
      unit: '%'
    });

    return metrics;
  }

  /**
   * Get auto-generated data for a specific month
   */
  async getAutoGeneratedData(month: number, year: number): Promise<AutoGeneratedData> {
    const startDate = startOfMonth(new Date(year, month - 1));
    const endDate = endOfMonth(new Date(year, month - 1));
    const previousMonthStart = startOfMonth(subMonths(startDate, 1));
    const previousMonthEnd = endOfMonth(subMonths(startDate, 1));

    const actionPoints = await this.generateActionPoints(startDate, endDate);
    const mergeRequestDashboard = await this.generateMRDashboard(startDate, endDate);
    const qualityMetrics = await this.generateQualityMetrics(startDate, endDate, previousMonthStart, previousMonthEnd);

    return {
      actionPoints,
      mergeRequestDashboard,
      qualityMetrics
    };
  }

  /**
   * Call LLM to generate human-readable highlight description from multiple MRs
   */
  private async generateHighlightDescriptionFromMultipleMRs(
    points: number,
    mrs: Array<{
      task_title: string;
      project_name: string;
      mr_title: string;
      mr_description: string;
      author_username: string;
      mr_url: string;
    }>
  ): Promise<string> {
    try {
      if (!OPENROUTER_API_KEY) {
        // Fallback to simple format if no API key
        const mrCount = mrs.length;
        const projects = [...new Set(mrs.map(mr => mr.project_name))].join(', ');
        return `${points}-point achievement across ${mrCount} MR${mrCount > 1 ? 's' : ''} (${projects})`;
      }

      // Build MR details for prompt
      const mrDetails = mrs.map((mr, idx) => `
MR ${idx + 1}:
- Task: ${mr.task_title}
- Project: ${mr.project_name}
- Title: ${mr.mr_title}
- Description: ${mr.mr_description?.substring(0, 200) || 'No description'}
- Author: ${mr.author_username}
`).join('\n');

      const prompt = `You are a technical writer creating a monthly report highlight.

This is a ${points}-point achievement (high value) completed through ${mrs.length} merge request${mrs.length > 1 ? 's' : ''}:

${mrDetails}

Create ONE concise, human-readable highlight (max 240 characters) that summarizes these achievements in a positive, professional tone. Focus on the overall impact and value delivered across all MRs.

Format: Start with an emoji, then describe the achievement.
Example: "üöÄ Delivered feature with automated review system and performance optimizations"

Return ONLY the highlight text with Project Name (Do not shortened) inside that highlight, nothing else.`;

      const api = axios.create({
        baseURL: OPENROUTER_API_URL,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
          'HTTP-Referer': process.env.APP_URL || 'http://localhost:9080',
        },
      });

      const response = await api.post('/chat/completions', {
        model: 'moonshotai/Kimi-K2-Instruct-0905',
        messages: [
          { role: 'system', content: 'You are a concise technical writer. Always respond with ONLY the requested text, no explanations or additional formatting.' },
          { role: 'user', content: prompt }
        ],
        temperature: 0.7,
        max_tokens: 200,
      });

      const llmResponse = response.data.choices[0].message.content.trim();
      if (llmResponse) {
        return llmResponse;
      }

      // Fallback
      const mrCount = mrs.length;
      const projects = [...new Set(mrs.map(mr => mr.project_name))].join(', ');
      return `${points}-point achievement across ${mrCount} MR${mrCount > 1 ? 's' : ''} (${projects})`;
    } catch (error) {
      console.error('Error generating highlight description with LLM:', error);
      // Fallback to simple format
      const mrCount = mrs.length;
      const projects = [...new Set(mrs.map(mr => mr.project_name))].join(', ');
      return `${points}-point achievement across ${mrCount} MR${mrCount > 1 ? 's' : ''} (${projects})`;
    }
  }

  /**
   * OLD METHOD - NOT USED ANYMORE
   */
  private async generateHighlightDescription_OLD(
    projectName: string,
    title: string,
    description: string,
    timeStr: string,
    author: string
  ): Promise<string> {
    try {
      if (!OPENROUTER_API_KEY) {
        // Fallback to simple format if no API key
        return `${projectName}: ${title.substring(0, 50)}${title.length > 50 ? '...' : ''} (${timeStr} - ${author})`;
      }

      const prompt = `You are a technical writer creating a monthly report highlight.

Given this merge request information:
- Project: ${projectName}
- Title: ${title}
- Description: ${description}
- Time taken: ${timeStr}
- Author: ${author}

Create a concise, human-readable highlight (max 100 characters) that describes the achievement in a positive, professional tone. Focus on the impact and value delivered.

Format: Start with an emoji, then describe the achievement.
Example: "üöÄ Implemented automated GitLab review system, reducing review time by 50%"

Return ONLY the highlight text, nothing else.`;

      const api = axios.create({
        baseURL: OPENROUTER_API_URL,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
          'HTTP-Referer': process.env.APP_URL || 'http://localhost:9080',
        },
      });

      const response = await api.post('/chat/completions', {
        model: 'moonshotai/Kimi-K2-Instruct-0905',
        messages: [
          { role: 'system', content: 'You are a concise technical writer. Always respond with ONLY the requested text, no explanations or additional formatting.' },
          { role: 'user', content: prompt }
        ],
        temperature: 0.7,
        max_tokens: 150,
      });

      const llmResponse = response.data.choices[0].message.content.trim();
      return llmResponse || `${projectName}: ${title.substring(0, 50)}${title.length > 50 ? '...' : ''} (${timeStr} - ${author})`;
    } catch (error) {
      console.error('Error generating highlight description with LLM:', error);
      // Fallback to simple format
      return `${projectName}: ${title.substring(0, 50)}${title.length > 50 ? '...' : ''} (${timeStr} - ${author})`;
    }
  }

  /**
   * Call LLM to generate human-readable lowlight description from multiple MRs
   */
  private async generateLowlightDescriptionFromMultipleMRs(
    points: number,
    mrs: Array<{
      task_title: string;
      project_name: string;
      mr_title: string;
      mr_description: string;
      author_username: string;
      mr_url: string;
      critical_issues_count: number;
    }>
  ): Promise<string> {
    try {
      if (!OPENROUTER_API_KEY) {
        // Fallback to simple format if no API key
        const mrCount = mrs.length;
        const projects = [...new Set(mrs.map(mr => mr.project_name))].join(', ');
        return `${points}-point tasks with ${mrCount} MR${mrCount > 1 ? 's' : ''} needing improvement (${projects})`;
      }

      // Build MR details for prompt
      const mrDetails = mrs.map((mr, idx) => `
MR ${idx + 1}:
- Task: ${mr.task_title}
- Project: ${mr.project_name}
- Title: ${mr.mr_title}
- Description: ${mr.mr_description?.substring(0, 200) || 'No description'}
- Author: ${mr.author_username}
- Issues: ${mr.critical_issues_count || 0} critical issue(s)
`).join('\n');

      const prompt = `You are a technical writer creating a monthly report lowlight (area for improvement).

This is a ${points}-point task (lower complexity) with ${mrs.length} merge request${mrs.length > 1 ? 's' : ''} that had some issues:

${mrDetails}

Create ONE concise, constructive lowlight (max 120 characters) that summarizes these issues in a professional, non-blaming tone. Focus on the learning opportunity and improvement areas.

Format: Start with an emoji, then describe the issue constructively.
Example: "‚ö†Ô∏è Multiple tasks revealed need for better testing and code review practices"

Return ONLY the lowlight text with Project Name (Do not shortened) inside that lowlight, nothing else.`;

      const api = axios.create({
        baseURL: OPENROUTER_API_URL,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
          'HTTP-Referer': process.env.APP_URL || 'http://localhost:9080',
        },
      });

      const response = await api.post('/chat/completions', {
        model: 'moonshotai/Kimi-K2-Instruct-0905',
        messages: [
          { role: 'system', content: 'You are a concise technical writer. Always respond with ONLY the requested text, no explanations or additional formatting.' },
          { role: 'user', content: prompt }
        ],
        temperature: 0.7,
        max_tokens: 200,
      });

      const llmResponse = response.data.choices[0].message.content.trim();
      if (llmResponse) {
        return llmResponse;
      }

      // Fallback
      const mrCount = mrs.length;
      const projects = [...new Set(mrs.map(mr => mr.project_name))].join(', ');
      return `${points}-point tasks with ${mrCount} MR${mrCount > 1 ? 's' : ''} needing improvement (${projects})`;
    } catch (error) {
      console.error('Error generating lowlight description with LLM:', error);
      // Fallback to simple format
      const mrCount = mrs.length;
      const projects = [...new Set(mrs.map(mr => mr.project_name))].join(', ');
      return `${points}-point tasks with ${mrCount} MR${mrCount > 1 ? 's' : ''} needing improvement (${projects})`;
    }
  }

  /**
   * OLD METHOD - NOT USED ANYMORE
   */
  private async generateLowlightDescription_OLD(
    projectName: string,
    title: string,
    description: string,
    issueCount: number,
    issueText: string,
    author: string
  ): Promise<string> {
    try {
      if (!OPENROUTER_API_KEY) {
        // Fallback to simple format if no API key
        return `${projectName}: ${title.substring(0, 50)}${title.length > 50 ? '...' : ''} (${issueCount} ${issueText} - ${author})`;
      }

      const prompt = `You are a technical writer creating a monthly report lowlight (area for improvement).

Given this merge request information:
- Project: ${projectName}
- Title: ${title}
- Description: ${description}
- Issues found: ${issueCount} ${issueText}
- Author: ${author}

Create a concise, constructive lowlight (max 100 characters) that describes the issue in a professional, non-blaming tone. Focus on the learning opportunity.

Format: Start with an emoji, then describe the issue constructively.
Example: "‚ö†Ô∏è Authentication module needed refactoring for better error handling"

Return ONLY the lowlight text, nothing else.`;

      const api = axios.create({
        baseURL: OPENROUTER_API_URL,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
          'HTTP-Referer': process.env.APP_URL || 'http://localhost:9080',
        },
      });

      const response = await api.post('/chat/completions', {
        model: 'moonshotai/Kimi-K2-Instruct-0905',
        messages: [
          { role: 'system', content: 'You are a concise technical writer. Always respond with ONLY the requested text, no explanations or additional formatting.' },
          { role: 'user', content: prompt }
        ],
        temperature: 0.7,
        max_tokens: 1150,
      });

      const llmResponse = response.data.choices[0].message.content.trim();
      return llmResponse || `${projectName}: ${title.substring(0, 50)}${title.length > 50 ? '...' : ''} (${issueCount} ${issueText} - ${author})`;
    } catch (error) {
      console.error('Error generating lowlight description with LLM:', error);
      // Fallback to simple format
      return `${projectName}: ${title.substring(0, 50)}${title.length > 50 ? '...' : ''} (${issueCount} ${issueText} - ${author})`;
    }
  }
}

export const monthlyReportService = new MonthlyReportService();

