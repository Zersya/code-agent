import { dbService } from './database.js';
import {
  MonthlyReportData,
  ActionPoint,
  TopContributor,
  QualityMetric,
  AutoGeneratedData,
  Highlight,
  Lowlight
} from '../models/monthly-report.js';
import { startOfMonth, endOfMonth, subMonths, format, differenceInHours } from 'date-fns';
import axios from 'axios';
import dotenv from 'dotenv';

dotenv.config();

const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY;
const OPENROUTER_API_URL = process.env.OPENROUTER_API_URL || 'https://openrouter.ai/api/v1';

export class MonthlyReportService {
  /**
   * Auto-generate monthly report data from existing database records
   */
  async generateMonthlyReportData(month: number, year: number): Promise<MonthlyReportData> {
    const startDate = startOfMonth(new Date(year, month - 1));
    const endDate = endOfMonth(new Date(year, month - 1));
    const previousMonthStart = startOfMonth(subMonths(startDate, 1));
    const previousMonthEnd = endOfMonth(subMonths(startDate, 1));

    // Generate each section
    const actionPoints = await this.generateActionPoints(startDate, endDate);
    const mrDashboard = await this.generateMRDashboard(startDate, endDate);
    const qualityMetrics = await this.generateQualityMetrics(startDate, endDate, previousMonthStart, previousMonthEnd);

    // Generate highlights and lowlights
    const highlights = await this.generateHighlights(startDate, endDate);
    const lowlights = await this.generateLowlights(startDate, endDate);

    const reportData: MonthlyReportData = {
      month,
      year,
      actionPoints,
      highlights,
      lowlights,
      techUpdate: {
        mergeRequestDashboard: mrDashboard,
        toolingChanges: [
          { description: 'Add tooling/infrastructure changes here' }
        ]
      },
      lessonsLearned: [
        {
          whatHappened: 'Describe what happened',
          whyItMatters: 'Explain why it matters',
          nextAction: 'Define preventive action'
        }
      ],
      productStrategy: {
        feedbackSummary: 'Add feedback summary here',
        feedbackLink: '',
        qualityMetrics
      },
      budgeting: {
        items: []
      },
      thankYouNote: 'Thank you to the team for your hard work this month! üëè'
    };

    return reportData;
  }

  /**
   * Generate action points from closed merge requests
   */
  private async generateActionPoints(startDate: Date, endDate: Date): Promise<ActionPoint[]> {
    const query = `
      SELECT
        mrt.title,
        mrt.author_username,
        mrt.merged_at,
        mrt.closed_at,
        mrt.status,
        p.name as project_name
      FROM merge_request_tracking mrt
      LEFT JOIN projects p ON mrt.project_id = p.project_id
      WHERE mrt.merged_at BETWEEN $1 AND $2
        OR mrt.closed_at BETWEEN $1 AND $2
      ORDER BY COALESCE(mrt.merged_at, mrt.closed_at) DESC
      LIMIT 50
    `;

    const result = await dbService.query(query, [startDate, endDate]);

    return result.rows.map(row => {
      // Minify action text - truncate if too long
      const action = row.title.length > 60
        ? row.title.substring(0, 57) + '...'
        : row.title;

      return {
        date: format(new Date(row.merged_at || row.closed_at), 'yyyy-MM-dd'),
        action,
        pic: row.author_username,
        status: row.status === 'merged' ? 'finish' as const : 'drop' as const,
        project_name: row.project_name || 'Unknown'
      };
    });
  }

  /**
   * Generate MR dashboard metrics
   */
  private async generateMRDashboard(startDate: Date, endDate: Date) {
    // Get total MRs created and merged
    const mrStatsQuery = `
      SELECT
        COUNT(*) as total_created,
        COUNT(CASE WHEN status = 'merged' THEN 1 END) as total_merged
      FROM merge_request_tracking
      WHERE created_at BETWEEN $1 AND $2
    `;
    const mrStatsResult = await dbService.query(mrStatsQuery, [startDate, endDate]);
    const mrStats = mrStatsResult.rows[0];

    const totalCreated = parseInt(mrStats.total_created) || 0;
    const totalMerged = parseInt(mrStats.total_merged) || 0;
    const mergeRate = totalCreated > 0 ? (totalMerged / totalCreated) * 100 : 0;

    // Get top contributors
    const topContributorsQuery = `
      SELECT
        author_username,
        COUNT(*) as mr_count
      FROM merge_request_tracking
      WHERE created_at BETWEEN $1 AND $2
      GROUP BY author_username
      ORDER BY mr_count DESC
      LIMIT 3
    `;
    const topContributorsResult = await dbService.query(topContributorsQuery, [startDate, endDate]);

    const topContributors: TopContributor[] = topContributorsResult.rows.map(row => ({
      username: row.author_username,
      mrCount: parseInt(row.mr_count)
    }));

    return {
      totalMRCreated: totalCreated,
      totalMRMerged: totalMerged,
      mergeRate: Math.round(mergeRate * 100) / 100,
      topContributors
    };
  }

  /**
   * Generate highlights from most time-consuming MRs (from different projects)
   */
  private async generateHighlights(startDate: Date, endDate: Date): Promise<Highlight[]> {
    const query = `
      WITH ranked_mrs AS (
        SELECT
          mrt.title,
          mrt.author_username,
          mrt.description,
          p.name as project_name,
          EXTRACT(EPOCH FROM (mrt.merged_at - mrt.created_at))/3600 as merge_time_hours,
          ROW_NUMBER() OVER (PARTITION BY p.project_id ORDER BY EXTRACT(EPOCH FROM (mrt.merged_at - mrt.created_at))/3600 DESC) as rn
        FROM merge_request_tracking mrt
        LEFT JOIN projects p ON mrt.project_id = p.project_id
        WHERE mrt.merged_at BETWEEN $1 AND $2
          AND mrt.status = 'merged'
          AND mrt.merged_at IS NOT NULL
      )
      SELECT * FROM ranked_mrs
      WHERE rn = 1
      ORDER BY merge_time_hours DESC
      LIMIT 5
    `;

    const result = await dbService.query(query, [startDate, endDate]);

    if (result.rows.length === 0) {
      return [{ description: 'Add your highlights here', completed: false }];
    }

    // Process with LLM for human-readable descriptions
    const highlights: Highlight[] = [];
    for (const row of result.rows) {
      const hours = Math.round(row.merge_time_hours);
      const days = Math.floor(hours / 24);
      const timeStr = days > 0 ? `${days}d ${hours % 24}h` : `${hours}h`;

      const llmDescription = await this.generateHighlightDescription(
        row.project_name,
        row.title,
        row.description || '',
        timeStr,
        row.author_username
      );

      highlights.push({
        description: llmDescription,
        completed: true
      });
    }

    return highlights;
  }

  /**
   * Generate lowlights from MRs with minor issues (from different projects)
   */
  private async generateLowlights(startDate: Date, endDate: Date): Promise<Lowlight[]> {
    const query = `
      WITH ranked_mrs AS (
        SELECT
          mrt.title,
          mrt.author_username,
          mrt.description,
          p.name as project_name,
          mrr.critical_issues_count,
          ROW_NUMBER() OVER (PARTITION BY p.project_id ORDER BY mrr.critical_issues_count DESC, mrt.merged_at DESC) as rn
        FROM merge_request_tracking mrt
        LEFT JOIN projects p ON mrt.project_id = p.project_id
        LEFT JOIN merge_request_reviews mrr ON mrt.project_id = mrr.project_id
          AND mrt.merge_request_iid = mrr.merge_request_iid
        WHERE mrt.merged_at BETWEEN $1 AND $2
          AND mrt.status = 'merged'
          AND mrr.critical_issues_count > 0
          AND mrr.critical_issues_count <= 3
      )
      SELECT * FROM ranked_mrs
      WHERE rn = 1
      ORDER BY critical_issues_count DESC
      LIMIT 5
    `;

    const result = await dbService.query(query, [startDate, endDate]);

    if (result.rows.length === 0) {
      return [];
    }

    // Process with LLM for human-readable descriptions
    const lowlights: Lowlight[] = [];
    for (const row of result.rows) {
      const issueText = row.critical_issues_count === 1 ? 'issue' : 'issues';

      const llmDescription = await this.generateLowlightDescription(
        row.project_name,
        row.title,
        row.description || '',
        row.critical_issues_count,
        issueText,
        row.author_username
      );

      lowlights.push({
        description: llmDescription,
        completed: false
      });
    }

    return lowlights;
  }

  /**
   * Generate quality metrics comparing current month to previous month
   */
  private async generateQualityMetrics(
    currentStart: Date,
    currentEnd: Date,
    previousStart: Date,
    previousEnd: Date
  ): Promise<QualityMetric[]> {
    const metrics: QualityMetric[] = [];

    // Average PR review time
    const reviewTimeQuery = `
      SELECT
        AVG(EXTRACT(EPOCH FROM (reviewed_at - created_at)) / 3600) as avg_hours
      FROM merge_request_reviews
      WHERE reviewed_at BETWEEN $1 AND $2
    `;

    const currentReviewTime = await dbService.query(reviewTimeQuery, [currentStart, currentEnd]);
    const previousReviewTime = await dbService.query(reviewTimeQuery, [previousStart, previousEnd]);

    const currentAvg = parseFloat(currentReviewTime.rows[0]?.avg_hours) || 0;
    const previousAvg = parseFloat(previousReviewTime.rows[0]?.avg_hours) || 0;

    metrics.push({
      metric: 'Average PR review time',
      previousValue: Math.round(previousAvg * 10) / 10,
      currentValue: Math.round(currentAvg * 10) / 10,
      trend: currentAvg < previousAvg ? 'down' : currentAvg > previousAvg ? 'up' : 'stable',
      unit: 'hours'
    });

    // Unit test coverage (if available - placeholder for now)
    // This would need to be tracked separately in your system
    metrics.push({
      metric: 'Unit-test coverage',
      previousValue: 0,
      currentValue: 0,
      trend: 'stable',
      unit: '%'
    });

    return metrics;
  }

  /**
   * Get auto-generated data for a specific month
   */
  async getAutoGeneratedData(month: number, year: number): Promise<AutoGeneratedData> {
    const startDate = startOfMonth(new Date(year, month - 1));
    const endDate = endOfMonth(new Date(year, month - 1));
    const previousMonthStart = startOfMonth(subMonths(startDate, 1));
    const previousMonthEnd = endOfMonth(subMonths(startDate, 1));

    const actionPoints = await this.generateActionPoints(startDate, endDate);
    const mergeRequestDashboard = await this.generateMRDashboard(startDate, endDate);
    const qualityMetrics = await this.generateQualityMetrics(startDate, endDate, previousMonthStart, previousMonthEnd);

    return {
      actionPoints,
      mergeRequestDashboard,
      qualityMetrics
    };
  }

  /**
   * Call LLM to generate human-readable highlight description
   */
  private async generateHighlightDescription(
    projectName: string,
    title: string,
    description: string,
    timeStr: string,
    author: string
  ): Promise<string> {
    try {
      if (!OPENROUTER_API_KEY) {
        // Fallback to simple format if no API key
        return `${projectName}: ${title.substring(0, 50)}${title.length > 50 ? '...' : ''} (${timeStr} - ${author})`;
      }

      const prompt = `You are a technical writer creating a monthly report highlight.

Given this merge request information:
- Project: ${projectName}
- Title: ${title}
- Description: ${description}
- Time taken: ${timeStr}
- Author: ${author}

Create a concise, human-readable highlight (max 100 characters) that describes the achievement in a positive, professional tone. Focus on the impact and value delivered.

Format: Start with an emoji, then describe the achievement.
Example: "üöÄ Implemented automated GitLab review system, reducing review time by 50%"

Return ONLY the highlight text, nothing else.`;

      const api = axios.create({
        baseURL: OPENROUTER_API_URL,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
          'HTTP-Referer': process.env.APP_URL || 'http://localhost:9080',
        },
      });

      const response = await api.post('/chat/completions', {
        model: 'moonshotai/Kimi-K2-Instruct-0905',
        messages: [
          { role: 'system', content: 'You are a concise technical writer. Always respond with ONLY the requested text, no explanations or additional formatting.' },
          { role: 'user', content: prompt }
        ],
        temperature: 0.7,
        max_tokens: 150,
      });

      const llmResponse = response.data.choices[0].message.content.trim();
      return llmResponse || `${projectName}: ${title.substring(0, 50)}${title.length > 50 ? '...' : ''} (${timeStr} - ${author})`;
    } catch (error) {
      console.error('Error generating highlight description with LLM:', error);
      // Fallback to simple format
      return `${projectName}: ${title.substring(0, 50)}${title.length > 50 ? '...' : ''} (${timeStr} - ${author})`;
    }
  }

  /**
   * Call LLM to generate human-readable lowlight description
   */
  private async generateLowlightDescription(
    projectName: string,
    title: string,
    description: string,
    issueCount: number,
    issueText: string,
    author: string
  ): Promise<string> {
    try {
      if (!OPENROUTER_API_KEY) {
        // Fallback to simple format if no API key
        return `${projectName}: ${title.substring(0, 50)}${title.length > 50 ? '...' : ''} (${issueCount} ${issueText} - ${author})`;
      }

      const prompt = `You are a technical writer creating a monthly report lowlight (area for improvement).

Given this merge request information:
- Project: ${projectName}
- Title: ${title}
- Description: ${description}
- Issues found: ${issueCount} ${issueText}
- Author: ${author}

Create a concise, constructive lowlight (max 100 characters) that describes the issue in a professional, non-blaming tone. Focus on the learning opportunity.

Format: Start with an emoji, then describe the issue constructively.
Example: "‚ö†Ô∏è Authentication module needed refactoring for better error handling"

Return ONLY the lowlight text, nothing else.`;

      const api = axios.create({
        baseURL: OPENROUTER_API_URL,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
          'HTTP-Referer': process.env.APP_URL || 'http://localhost:9080',
        },
      });

      const response = await api.post('/chat/completions', {
        model: 'moonshotai/Kimi-K2-Instruct-0905',
        messages: [
          { role: 'system', content: 'You are a concise technical writer. Always respond with ONLY the requested text, no explanations or additional formatting.' },
          { role: 'user', content: prompt }
        ],
        temperature: 0.7,
        max_tokens: 1150,
      });

      const llmResponse = response.data.choices[0].message.content.trim();
      return llmResponse || `${projectName}: ${title.substring(0, 50)}${title.length > 50 ? '...' : ''} (${issueCount} ${issueText} - ${author})`;
    } catch (error) {
      console.error('Error generating lowlight description with LLM:', error);
      // Fallback to simple format
      return `${projectName}: ${title.substring(0, 50)}${title.length > 50 ? '...' : ''} (${issueCount} ${issueText} - ${author})`;
    }
  }
}

export const monthlyReportService = new MonthlyReportService();

