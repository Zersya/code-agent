import { dbService } from './database.js';
import {
  MonthlyReportData,
  ActionPoint,
  TopContributor,
  QualityMetric,
  AutoGeneratedData,
  Highlight,
  Lowlight
} from '../models/monthly-report.js';
import { startOfMonth, endOfMonth, subMonths, format, differenceInHours } from 'date-fns';

export class MonthlyReportService {
  /**
   * Auto-generate monthly report data from existing database records
   */
  async generateMonthlyReportData(month: number, year: number): Promise<MonthlyReportData> {
    const startDate = startOfMonth(new Date(year, month - 1));
    const endDate = endOfMonth(new Date(year, month - 1));
    const previousMonthStart = startOfMonth(subMonths(startDate, 1));
    const previousMonthEnd = endOfMonth(subMonths(startDate, 1));

    // Generate each section
    const actionPoints = await this.generateActionPoints(startDate, endDate);
    const mrDashboard = await this.generateMRDashboard(startDate, endDate);
    const qualityMetrics = await this.generateQualityMetrics(startDate, endDate, previousMonthStart, previousMonthEnd);

    // Generate highlights and lowlights
    const highlights = await this.generateHighlights(startDate, endDate);
    const lowlights = await this.generateLowlights(startDate, endDate);

    const reportData: MonthlyReportData = {
      month,
      year,
      actionPoints,
      highlights,
      lowlights,
      techUpdate: {
        mergeRequestDashboard: mrDashboard,
        toolingChanges: [
          { description: 'Add tooling/infrastructure changes here' }
        ]
      },
      lessonsLearned: [
        {
          whatHappened: 'Describe what happened',
          whyItMatters: 'Explain why it matters',
          nextAction: 'Define preventive action'
        }
      ],
      productStrategy: {
        feedbackSummary: 'Add feedback summary here',
        feedbackLink: '',
        qualityMetrics
      },
      budgeting: {
        items: []
      },
      thankYouNote: 'Thank you to the team for your hard work this month! üëè'
    };

    return reportData;
  }

  /**
   * Generate action points from closed merge requests
   */
  private async generateActionPoints(startDate: Date, endDate: Date): Promise<ActionPoint[]> {
    const query = `
      SELECT
        mrt.title,
        mrt.author_username,
        mrt.merged_at,
        mrt.closed_at,
        mrt.status,
        p.name as project_name
      FROM merge_request_tracking mrt
      LEFT JOIN projects p ON mrt.project_id = p.project_id
      WHERE mrt.merged_at BETWEEN $1 AND $2
        OR mrt.closed_at BETWEEN $1 AND $2
      ORDER BY COALESCE(mrt.merged_at, mrt.closed_at) DESC
      LIMIT 50
    `;

    const result = await dbService.query(query, [startDate, endDate]);

    return result.rows.map(row => {
      // Minify action text - truncate if too long
      const action = row.title.length > 60
        ? row.title.substring(0, 57) + '...'
        : row.title;

      return {
        date: format(new Date(row.merged_at || row.closed_at), 'yyyy-MM-dd'),
        action,
        pic: row.author_username,
        status: row.status === 'merged' ? 'finish' as const : 'drop' as const,
        project_name: row.project_name || 'Unknown'
      };
    });
  }

  /**
   * Generate MR dashboard metrics
   */
  private async generateMRDashboard(startDate: Date, endDate: Date) {
    // Get total MRs created and merged
    const mrStatsQuery = `
      SELECT
        COUNT(*) as total_created,
        COUNT(CASE WHEN status = 'merged' THEN 1 END) as total_merged
      FROM merge_request_tracking
      WHERE created_at BETWEEN $1 AND $2
    `;
    const mrStatsResult = await dbService.query(mrStatsQuery, [startDate, endDate]);
    const mrStats = mrStatsResult.rows[0];

    const totalCreated = parseInt(mrStats.total_created) || 0;
    const totalMerged = parseInt(mrStats.total_merged) || 0;
    const mergeRate = totalCreated > 0 ? (totalMerged / totalCreated) * 100 : 0;

    // Get top contributors
    const topContributorsQuery = `
      SELECT
        author_username,
        COUNT(*) as mr_count
      FROM merge_request_tracking
      WHERE created_at BETWEEN $1 AND $2
      GROUP BY author_username
      ORDER BY mr_count DESC
      LIMIT 3
    `;
    const topContributorsResult = await dbService.query(topContributorsQuery, [startDate, endDate]);

    const topContributors: TopContributor[] = topContributorsResult.rows.map(row => ({
      username: row.author_username,
      mrCount: parseInt(row.mr_count)
    }));

    return {
      totalMRCreated: totalCreated,
      totalMRMerged: totalMerged,
      mergeRate: Math.round(mergeRate * 100) / 100,
      topContributors
    };
  }

  /**
   * Generate highlights from most time-consuming MRs
   */
  private async generateHighlights(startDate: Date, endDate: Date): Promise<Highlight[]> {
    const query = `
      SELECT
        mrt.title,
        mrt.author_username,
        p.name as project_name,
        EXTRACT(EPOCH FROM (mrt.merged_at - mrt.created_at))/3600 as merge_time_hours
      FROM merge_request_tracking mrt
      LEFT JOIN projects p ON mrt.project_id = p.project_id
      WHERE mrt.merged_at BETWEEN $1 AND $2
        AND mrt.status = 'merged'
        AND mrt.merged_at IS NOT NULL
      ORDER BY merge_time_hours DESC
      LIMIT 5
    `;

    const result = await dbService.query(query, [startDate, endDate]);

    if (result.rows.length === 0) {
      return [{ description: 'Add your highlights here', completed: false }];
    }

    return result.rows.map(row => {
      const hours = Math.round(row.merge_time_hours);
      const days = Math.floor(hours / 24);
      const timeStr = days > 0 ? `${days}d ${hours % 24}h` : `${hours}h`;

      return {
        description: `${row.project_name}: ${row.title.substring(0, 50)}${row.title.length > 50 ? '...' : ''} (${timeStr} - ${row.author_username})`,
        completed: true
      };
    });
  }

  /**
   * Generate lowlights from MRs with minor issues
   */
  private async generateLowlights(startDate: Date, endDate: Date): Promise<Lowlight[]> {
    const query = `
      SELECT
        mrt.title,
        mrt.author_username,
        p.name as project_name,
        mrr.critical_issues_count
      FROM merge_request_tracking mrt
      LEFT JOIN projects p ON mrt.project_id = p.project_id
      LEFT JOIN merge_request_reviews mrr ON mrt.project_id = mrr.project_id
        AND mrt.merge_request_iid = mrr.merge_request_iid
      WHERE mrt.merged_at BETWEEN $1 AND $2
        AND mrt.status = 'merged'
        AND mrr.critical_issues_count > 0
        AND mrr.critical_issues_count <= 3
      ORDER BY mrr.critical_issues_count DESC, mrt.merged_at DESC
      LIMIT 5
    `;

    const result = await dbService.query(query, [startDate, endDate]);

    if (result.rows.length === 0) {
      return [];
    }

    return result.rows.map(row => {
      const issueText = row.critical_issues_count === 1 ? 'issue' : 'issues';
      return {
        description: `${row.project_name}: ${row.title.substring(0, 50)}${row.title.length > 50 ? '...' : ''} (${row.critical_issues_count} ${issueText} - ${row.author_username})`,
        completed: false
      };
    });
  }

  /**
   * Generate quality metrics comparing current month to previous month
   */
  private async generateQualityMetrics(
    currentStart: Date,
    currentEnd: Date,
    previousStart: Date,
    previousEnd: Date
  ): Promise<QualityMetric[]> {
    const metrics: QualityMetric[] = [];

    // Average PR review time
    const reviewTimeQuery = `
      SELECT
        AVG(EXTRACT(EPOCH FROM (reviewed_at - created_at)) / 3600) as avg_hours
      FROM merge_request_reviews
      WHERE reviewed_at BETWEEN $1 AND $2
    `;

    const currentReviewTime = await dbService.query(reviewTimeQuery, [currentStart, currentEnd]);
    const previousReviewTime = await dbService.query(reviewTimeQuery, [previousStart, previousEnd]);

    const currentAvg = parseFloat(currentReviewTime.rows[0]?.avg_hours) || 0;
    const previousAvg = parseFloat(previousReviewTime.rows[0]?.avg_hours) || 0;

    metrics.push({
      metric: 'Average PR review time',
      previousValue: Math.round(previousAvg * 10) / 10,
      currentValue: Math.round(currentAvg * 10) / 10,
      trend: currentAvg < previousAvg ? 'down' : currentAvg > previousAvg ? 'up' : 'stable',
      unit: 'hours'
    });

    // Unit test coverage (if available - placeholder for now)
    // This would need to be tracked separately in your system
    metrics.push({
      metric: 'Unit-test coverage',
      previousValue: 0,
      currentValue: 0,
      trend: 'stable',
      unit: '%'
    });

    return metrics;
  }

  /**
   * Get auto-generated data for a specific month
   */
  async getAutoGeneratedData(month: number, year: number): Promise<AutoGeneratedData> {
    const startDate = startOfMonth(new Date(year, month - 1));
    const endDate = endOfMonth(new Date(year, month - 1));
    const previousMonthStart = startOfMonth(subMonths(startDate, 1));
    const previousMonthEnd = endOfMonth(subMonths(startDate, 1));

    const actionPoints = await this.generateActionPoints(startDate, endDate);
    const mergeRequestDashboard = await this.generateMRDashboard(startDate, endDate);
    const qualityMetrics = await this.generateQualityMetrics(startDate, endDate, previousMonthStart, previousMonthEnd);

    return {
      actionPoints,
      mergeRequestDashboard,
      qualityMetrics
    };
  }
}

export const monthlyReportService = new MonthlyReportService();

