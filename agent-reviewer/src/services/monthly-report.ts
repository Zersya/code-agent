import { dbService } from './database.js';
import { 
  MonthlyReportData, 
  ActionPoint, 
  TopContributor, 
  QualityMetric,
  AutoGeneratedData 
} from '../models/monthly-report.js';
import { startOfMonth, endOfMonth, subMonths, format } from 'date-fns';

export class MonthlyReportService {
  /**
   * Auto-generate monthly report data from existing database records
   */
  async generateMonthlyReportData(month: number, year: number): Promise<MonthlyReportData> {
    const startDate = startOfMonth(new Date(year, month - 1));
    const endDate = endOfMonth(new Date(year, month - 1));
    const previousMonthStart = startOfMonth(subMonths(startDate, 1));
    const previousMonthEnd = endOfMonth(subMonths(startDate, 1));

    // Generate each section
    const actionPoints = await this.generateActionPoints(startDate, endDate);
    const mrDashboard = await this.generateMRDashboard(startDate, endDate);
    const qualityMetrics = await this.generateQualityMetrics(startDate, endDate, previousMonthStart, previousMonthEnd);

    const reportData: MonthlyReportData = {
      month,
      year,
      actionPoints,
      highlights: [
        { description: 'Add your highlights here', completed: false }
      ],
      lowlights: [],
      techUpdate: {
        mergeRequestDashboard: mrDashboard,
        toolingChanges: [
          { description: 'Add tooling/infrastructure changes here' }
        ]
      },
      lessonsLearned: [
        {
          whatHappened: 'Describe what happened',
          whyItMatters: 'Explain why it matters',
          nextAction: 'Define preventive action'
        }
      ],
      productStrategy: {
        feedbackSummary: 'Add feedback summary here',
        feedbackLink: '',
        qualityMetrics
      },
      budgeting: {
        items: []
      },
      thankYouNote: 'Thank you to the team for your hard work this month! üëè'
    };

    return reportData;
  }

  /**
   * Generate action points from closed merge requests
   */
  private async generateActionPoints(startDate: Date, endDate: Date): Promise<ActionPoint[]> {
    const query = `
      SELECT 
        mrt.title,
        mrt.author_username,
        mrt.merged_at,
        mrt.status
      FROM merge_request_tracking mrt
      WHERE mrt.merged_at BETWEEN $1 AND $2
        OR mrt.closed_at BETWEEN $1 AND $2
      ORDER BY COALESCE(mrt.merged_at, mrt.closed_at) DESC
      LIMIT 20
    `;

    const result = await dbService.query(query, [startDate, endDate]);
    
    return result.rows.map(row => ({
      date: format(new Date(row.merged_at || row.closed_at), 'yyyy-MM-dd'),
      action: row.title,
      pic: row.author_username,
      status: row.status === 'merged' ? 'finish' as const : 'drop' as const
    }));
  }

  /**
   * Generate MR dashboard metrics
   */
  private async generateMRDashboard(startDate: Date, endDate: Date) {
    // Get total MRs created and merged
    const mrStatsQuery = `
      SELECT 
        COUNT(*) as total_created,
        COUNT(CASE WHEN status = 'merged' THEN 1 END) as total_merged
      FROM merge_request_tracking
      WHERE created_at BETWEEN $1 AND $2
    `;
    const mrStatsResult = await dbService.query(mrStatsQuery, [startDate, endDate]);
    const mrStats = mrStatsResult.rows[0];

    const totalCreated = parseInt(mrStats.total_created) || 0;
    const totalMerged = parseInt(mrStats.total_merged) || 0;
    const mergeRate = totalCreated > 0 ? (totalMerged / totalCreated) * 100 : 0;

    // Get top contributors
    const topContributorsQuery = `
      SELECT 
        author_username,
        COUNT(*) as mr_count
      FROM merge_request_tracking
      WHERE created_at BETWEEN $1 AND $2
      GROUP BY author_username
      ORDER BY mr_count DESC
      LIMIT 3
    `;
    const topContributorsResult = await dbService.query(topContributorsQuery, [startDate, endDate]);
    
    const topContributors: TopContributor[] = topContributorsResult.rows.map(row => ({
      username: row.author_username,
      mrCount: parseInt(row.mr_count)
    }));

    return {
      totalMRCreated: totalCreated,
      totalMRMerged: totalMerged,
      mergeRate: Math.round(mergeRate * 100) / 100,
      topContributors
    };
  }

  /**
   * Generate quality metrics comparing current month to previous month
   */
  private async generateQualityMetrics(
    currentStart: Date, 
    currentEnd: Date, 
    previousStart: Date, 
    previousEnd: Date
  ): Promise<QualityMetric[]> {
    const metrics: QualityMetric[] = [];

    // Average PR review time
    const reviewTimeQuery = `
      SELECT 
        AVG(EXTRACT(EPOCH FROM (reviewed_at - created_at)) / 3600) as avg_hours
      FROM merge_request_reviews
      WHERE reviewed_at BETWEEN $1 AND $2
    `;
    
    const currentReviewTime = await dbService.query(reviewTimeQuery, [currentStart, currentEnd]);
    const previousReviewTime = await dbService.query(reviewTimeQuery, [previousStart, previousEnd]);
    
    const currentAvg = parseFloat(currentReviewTime.rows[0]?.avg_hours) || 0;
    const previousAvg = parseFloat(previousReviewTime.rows[0]?.avg_hours) || 0;
    
    metrics.push({
      metric: 'Average PR review time',
      previousValue: Math.round(previousAvg * 10) / 10,
      currentValue: Math.round(currentAvg * 10) / 10,
      trend: currentAvg < previousAvg ? 'down' : currentAvg > previousAvg ? 'up' : 'stable',
      unit: 'hours'
    });

    // Unit test coverage (if available - placeholder for now)
    // This would need to be tracked separately in your system
    metrics.push({
      metric: 'Unit-test coverage',
      previousValue: 0,
      currentValue: 0,
      trend: 'stable',
      unit: '%'
    });

    return metrics;
  }

  /**
   * Get auto-generated data for a specific month
   */
  async getAutoGeneratedData(month: number, year: number): Promise<AutoGeneratedData> {
    const startDate = startOfMonth(new Date(year, month - 1));
    const endDate = endOfMonth(new Date(year, month - 1));
    const previousMonthStart = startOfMonth(subMonths(startDate, 1));
    const previousMonthEnd = endOfMonth(subMonths(startDate, 1));

    const actionPoints = await this.generateActionPoints(startDate, endDate);
    const mergeRequestDashboard = await this.generateMRDashboard(startDate, endDate);
    const qualityMetrics = await this.generateQualityMetrics(startDate, endDate, previousMonthStart, previousMonthEnd);

    return {
      actionPoints,
      mergeRequestDashboard,
      qualityMetrics
    };
  }
}

export const monthlyReportService = new MonthlyReportService();

